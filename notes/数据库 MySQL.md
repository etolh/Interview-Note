# MySQL

## 一. 锁与事务实现

### MYISAM表锁
偏向MyISAM存储引擎，开销小，加锁快，无死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
MYISAM在读表前自动对表加读锁，在写表前自动对表加写锁。

> 加锁: lock table t1 read/write;
1. 用户A给表A加了读锁之后，只能读表A，不能写表A（报错），也不能读写其他表（报错）。
2. 此时用户B(未加锁）可以读表A，可以读写其他表，但是写表A时会出现阻塞（未报错），直至用户A释放表A的锁之后才解除阻塞，执行命令。



### 事务并发带来的问题
1. 脏写(丢失修改）：两个事务都对一个数据进行了修改，一个事务的修改覆盖了另一个事务的修改。
1. 脏读（读-DB结果不一致）：在一个事务中，读取其他事务未提交的数据，其他事务回滚后，导致读到的数据与数据库中的数据不一致； 
2. 不可重复读（读-读结果不一致）：一个事务中多次读取相同记录结果不一致（另一事务对该记录进行增改删）；
3. 幻读（读-写，用写来验证读，结果不一致）：一个事务中读取某个范围内的记录，另一个事务在该范围内插入新的记录。

### 隔离级别
为解决这些出现的问题，Mysql通过设置事务间的隔离性减少并发问题
1. 读未提交(Read Uncommitted)：一个事务可以读取其他事务未提交的结果，出现脏读。
2. 读已提交(Read Committed)：一个事务读取到其他事务已经提交的数据。Oracle等多数数据库默认都是该级别，出现不重复读
3. 可重复读(Repeated Read)：确保同一事务的多个实例在并发读取数据时，会看到相同结果。可重复读。InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻读。
4. 串行读(Serializable)：完全串行化的读，一个事务执行完毕后另一个事务才能执行，每次读都需要获得表级共享锁，读写相互都会阻塞。

![隔离级别](pics\db_tx_iso.jpg)

https://www.cnblogs.com/zhoujinyi/p/3437475.html

### MVCC
1. MVCC简单来说，就是保存数据在不同时间的版本，通过对比当前事务版本获取某一个版本的数据，从而实现并发控制，实现读已提交、可重复读的问题。

#### 逻辑实现
数据库每条记录都有三个隐藏列，其中两个和MVCC相关：创建记录的事务版本号 DB_TRX_ID 和 删除记录的版本号 DB_ROLL_ID
1. 当一个事务插入数据时，将新插入行的创建版本号设置为当前事务版本号，删除版本号设置为NULL
2. 当一个事务删除数据时，数据行被没有真正被删除，而是将删除版本号设置为当前版本号
3. 当一个事务更新数据时，先复制一条被修改的记录，将旧的记录的删除版本号设置为当前版本号，新的记录创建版本号也设置为当前版本号。

4. 当事务进行查询时，规则如下:
    1. 查找创建版本号早于当前版本号的记录：保证读取到的数据是当前事务开始前已经存在的数据，或是自身插入或修改的。
    2. 记录版本号要么是NULL，要么是大于当前版本号的：保证事务读取的记录在事务开始前未被删除
    只要满足这两条，才作为返回结果。


#### 底层实现    
redo log：防止事务在执行过程中丢失问题，在事务执行期间将对数据集的修改也保存到redo log（buffer）中；当执行期间若故障或断电，则可以根据redo log恢复到最近一次提交。
undo log: 用于事务的回滚。在事务执行期间事务前面的状态保存到undo log（buffer）；若当前事务回滚，则根据undo log恢复到以前的状态。
当事务提交时，redo log buffer中修改保存到磁盘redo log中。undo log则不再需要，清除掉。
