# 数据库理论
## 一. 事务
### 概念
1. 用户定义的一组数据库操作序列，要么全做，要么全部不做，是不可分割的工作单位。

### 4大特性ACID
1.	原子性（atomicity）：一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做；
2.	一致性（consistency）：事务必须使数据库从一个一致性状态变成另一个一致性状态；
3.	隔离性（isolation）：一个事务的执行不能被其他事务干扰；
4.	持续性（durability）：也称永久性，指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的．


### 数据库操作语句
1. BEGIN 或 START TRANSACTION 显式地开启一个事务；
2. COMMIT 也可以使用 COMMIT WORK，不过二者是等价的。COMMIT 会提交事务，并使已对数据库进行的所有修改成为永久性的；
3. ROLLBACK 也可以使用 ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；
4. SAVEPOINT identifier，SAVEPOINT 允许在事务中创建一个保存点，一个事务中可以有多个 SAVEPOINT；
5. RELEASE SAVEPOINT identifier 删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；
6. ROLLBACK TO identifier 把事务回滚到标记点；
7. SET TRANSACTION 用来设置事务的隔离级别。InnoDB 存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。

### 事务处理方法
1. 用 BEGIN, ROLLBACK, COMMIT来实现
    + BEGIN 开始一个事务
    + ROLLBACK 事务回滚
    + COMMIT 事务确认
2. 直接用 SET 来改变 MySQL 的自动提交模式:
    + SET AUTOCOMMIT=0 禁止自动提交
    + SET AUTOCOMMIT=1 开启自动提交(默认)

http://www.runoob.com/mysql/mysql-transaction.html

### 事务状态
1. 开始事务后，处于活动状态；当执行完最后一条语句时（非commit），处于部分提交状态。执行commit，处于提交状态，成功完成事务，永久写入数据库。
2. 当无法正常执行时，处于失败状态；执行rollback，数据库恢复到初始状态。

![tx_state](pics\db_tx_state_1.png)



## 二. 并发控制
### 1. 概述
1. 多用户数据库：允许多个用户同时使用的数据库（订票系统）
2. 不同的多事务执行方式：
	1. 串行执行：每个时刻只有一个事务运行，其他事务必须等到这个事务结束后方能运行。
	2. 交叉并发方式：单处理机系统中，事务的并发执行实际上是这些并行事务的并行操作轮流交叉运行（不是真正的并发，但是提高了系统效率）
    3. 同时并发方式：多处理机系统中，每个处理机可以运行一个事务，多个处理机可以同时运行多个事务，实现多个事务真正的并行运行。

3. 并发执行带来的问题：
	1. 多个事务同时存取同一数据（共享资源）
	2. 存取不正确的数据，破坏事务一致性和数据库一致性

1. 并发操作带来的数据不一致性包括
	1. 丢失修改（lost update）
	2. 不可重复读（non-repeatable read）
	3. 读脏数据（dirty read）

2. 并发控制机制的任务：
	1. 对并发操作进行正确的调度
	2. 保证事务的隔离性
	3. 保证数据库的一致性

3. 并发控制的主要技术
	1. 封锁（locking）（主要使用的）
	2. 时间戳（timestamp）
	3. 乐观控制法（optimistic scheduler）
	4. 多版本并发控制（multi-version concurrency control ，MVCC）


### 2. 封锁
1. 封锁是指，事务在对某个数据对象进行操作前，先向系统发送请求，对其加锁；在事务释放锁前，其他事务不能操作该数据对象。

2. 基本封锁类型:
    1. 排他锁Exclusive：排它锁又称写锁，X锁，对数据A加了排它锁之后，其他事务不能对A加任何类型的锁（排斥读和写）
    2. 共享锁Share：共享锁又称读锁，S锁，对A加了共享锁之后，其他事务只能对A加S锁，不能加X锁（只排斥写）。

    ![锁](pics\db_lock.png)

### 3. 封锁协议
1. 封锁协议规定了如何对数据对象加X锁和S锁，常用的封锁协议：三级封锁协议；三级封锁协议在不同程度上解决了并发问题，为并发操作的正确调度提供一定的保证。

#### 一级封锁协议
事务T在修改数据A之前，必须对其加X锁，直到事务结束（commit/rollback）才能释放。
一级封锁可以防止丢失修改；但读数据不加锁，会出现脏读、不可重读。

#### 二级封锁协议

在一级封锁上（写前加X锁，结束才释放），事务T在读取数据A之前，必须对其加S锁，**读取完毕**即可能释放。
二级封锁可以防止丢失修改、脏读；但读完数据即释放，会出现不可重读。

#### 三级封锁协议
在一级封锁上，事务T在读取数据A之前，必须对其加S锁，直到事务结束（commit/rollback）才能释放S锁。
三级封锁可以防止丢失修改、脏读、不可重读。

![锁](pics\db_lock2.png)

### 4. 两段锁协议
1. 可串行性 <br>
　　并行操作对并行事务的操作的调度是随机的，不同的调度可能产生不同的结果。在这些不同的调度中，肯定有些调度的结果是正确的，究竟哪些调度是正确的呢？
　　若每个事务的基本操作都串连在一起，没有其它事务的操作与之交叉执行，这样的调度称为串行调度，多个事务的的串行调度，其执行结果一定是正确的。但串行调度限制了系统并行性的发挥，而很多并行调度又不具有串行调度的结果，所以我们必须研究具有串行调度效果的并行调度方法。

2. 定义：当且仅当某组并发事务的交叉调度产生的结果和这些事务的某一串行调度的结果相同，则称这个交叉调度是可串行化。

3. 可串行化是并行事务正确性的准则，一个交叉调度，当且仅当它是可串行化的，它才是正确的。两段锁协议是保证并行事务可串行化的方法。

1. 两阶段锁协议是指，将加锁和解锁分为两个阶段执行；加锁阶段（扩展）只允许加锁操作，解锁阶段（收缩）只允许解锁操作。不允许解锁操作后再出现加锁。
2. 若所有并发执行的事务都遵循两阶段锁，则对这些事务的并发执行策略都是串行化的。（充分条件）
3. 遵循两阶段锁的事务可能出现死锁；事务T1、T2处于扩展阶段，但又同时请求对方已占有的锁。
4. 因此，又有了一次封锁法。一次封锁法要求事务必须一次性将所有要使用的数据全部加锁，否则就不能继续执行。因此，一次封锁法遵守两段锁协议，但两段锁并不要求事务必须一次性将所有要使用的数据全部加锁，这一点与一次性封锁不同，这就是遵守两段锁协议仍可能发生死锁的原因所在。

https://blog.csdn.net/aigoogle/article/details/25804285


### 5. 饥饿与死锁
#### 饥饿
1. 事务T1封锁了数据R，事务T2又请求封锁R，于是T2等待。T3也请求封锁R，当T1释放了R上的封锁之后，系统首先批准了T3的请求，T2仍然等待。 T4又请求封锁R，当T3释放了R上的封锁之后系统又批准了T4的请求……T2有可能永远等待，这就是饥饿的情形
 
2. 避免饥饿的方法：先来先服务 <br>
    当多个事务请求封锁同一数据对象时，按请求封锁的先后次序对这些事务排队。该数据对象上的锁一旦释放，首先批准申请队列中第一个事务获得锁。

#### 1.死锁
1. 事务T1封锁了数据R1， T2封锁了数据R2。 T1又请求封锁R2，因T2已封锁了R2，于是T1等待T2释放R2上的锁。 接着T2又申请封锁R1，因T1已封锁了R1，T2也只能等待T1释放R1上的锁。 这样T1在等待T2，而T2又在等待T1，T1和T2两个事务永远不能结束，形成死锁。
 
2. 解决死锁的方法：预防、诊断和解除
    1. 死锁的预防
    产生死锁的原因是两个或多个事务都已经封锁了一些数据对象，然后又都请求对已被其他事务封锁的数据对象加锁，从而出现死等待。
    预防死锁发生就是破坏产生死锁的条件
    方法
        1. 一次封锁法：要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行。
	存在的问题：降低系统的并发度；难以实现精确确定封锁对象
	    2. 顺序封锁法：预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实施封锁。

    2. 存在的问题：
        1. 维护成本：数据库系统中的封锁对象极多，并且在不断地变化
        2. 难以实现：很难实现确定每一个事务要封锁哪些对象

    3. DBMS普通采用的诊断并解除死锁的方法

3. 死锁的诊断和解除
    1. 方法：超时法和事务等待图法
	    1. 超时法：如果一个事务的等待时间超过了规定的时限，就认为发生了死锁
		优点：实现简单
		缺点：误判死锁；时限若设置太长，死锁发生后不能及时发现。

	    2. 事务等待图法：用事务等待图动态反映所有事务的等待情况事务。<br>
        等待图是一个有向图G=(T，U)，T为结点的集合，每个结点表示正运行的事务， U为边的集合，每条边表示事务等待的情况。若T1等待T2，则T1、T2之间划一条有向边，从T1指向T2。并发控制子系统周期性地（比如每隔数秒）生成事务等待图，检测事务。如果发现图中存在回路，则表示系统中出现了死锁。

		![锁](pics\db_dead_lock.png)

    2. 解除死锁：并发控制子系统选择一个处理死锁代价最小的事务，将其撤销。释放该事务持有的所有的锁，使其他事务能够继续运行下去。
 


### 6. 封锁粒度
1. 封锁对象的大小称为封锁粒度（granularity）。封锁的对象可以是逻辑单元（属性值、属性值集合、元组、关系、索引项、数据库），也可以是物理单元（页、物理记录）。

2. 选择封锁粒度原则：
	1. 封锁粒度和系统的并发度和并发控制的开销密切相关
	2. 封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越低，系统开销也越小；
    3. 封锁的粒度越小，并发度较高，但系统开销也就越大

    ![隔离级别](pics\db_lock_gran.png)

#### 7. 多粒度封锁
1. 一个事务中支持多种不同封锁粒度，称为多粒度封锁。
选择封锁粒度应该同时考虑封锁开销和并发度两个因素，适当选择封锁粒度以求得最优的效果。
需要处理多个关系的大量元组的用户事务：以数据库为封锁单位
需要处理大量元组的用户事务：以关系为封锁单元
只处理少量元组的用户事务：以元组为封锁单位

2. 多粒度树
    1. 以树形结构来表示多级封锁粒度。根结点是整个数据库，表示最大的数据粒度，叶结点表示最小的数据粒度。

3. 多粒度封锁协议：
    1. 允许多粒度树中的每个节点被独立地加锁，对一个节点加锁意味着这个节点的所有子节点也被加以同样类型的锁。因此，在多粒度封锁中一个数据对象可能以显式封锁和隐式封锁两种方式封锁。
        + 显式封锁：直接加到数据对象上的封锁
        + 隐式封锁：该数据对象没有独立加锁，是由于其上级结点加锁而使该数据对象加上了锁
        + 显式封锁和隐式封锁的效果是一样的

    系统检查封锁冲突时要检查显式封锁，还要检查隐式封锁

4. 例如事务T要对关系R1加X锁，系统必须搜索其上级结点数据库、关系R1，还要搜索R1的下级结点，即R1中的每一个元组。如果其中某一个数据对象已经加了不相容锁，则T必须等待。

5. 对某个数据对象加锁，系统要检查该数据对象上有无显式封锁与之冲突；再检查其所有上级节点，看本事务的显式封锁是否与该数据对象上的隐式封锁（由于上级节点已加的封锁造成的）冲突；还要检查其所有下级节点，看它们的显式封锁是否与本事务的隐式封锁（将加到下级节点的封锁）冲突。

6. 这种检查方法效率较低，引入一种新的锁，意向锁。有了意向锁，DBMS就无须逐个检查下一级节点的显式封锁。




### 8. 意向锁
1. 意向锁：
    1. 如果对一个节点加意向锁，则可说明该节点的下层节点正在被加锁；对任一节点加锁时，必须先对它的上层节点加意向锁。例如，对任一元组加锁时，必须先对它所在的数据库和关系加意向锁。

2. 三种常用的意向锁：意向共享锁（Intent Share Lock，IS锁）；意向排它锁（Intent Exclusive Lock，IX锁）；共享意向排它锁（Share Intent Exclusive Lock，SIX锁）。

    1. IS锁
    如果对一个数据对象加IS锁，表示它的子节点拟加S锁。
    例如：事务T1要对R1中某个元组加S锁，则要首先对关系R1和数据库加IS锁

    2. IX锁
    如果对一个数据对象加IX锁，表示它的子节点拟加X锁。
    例如：事务T1要对R1中某个元组加X锁，则要首先对关系R1和数据库加IX锁

    3. SIX锁
    如果对一个数据对象加SIX锁，表示对它加S锁，再加IX锁，即SIX = S + IX。
    例如：对某个表加SIX锁，则表示该事务要读整个表（所以要对该表加S锁），同时会更新个别元组（所以要对该表加IX锁）

    ![意向锁](pics\db_intent_lock.png)
    意向锁的强度： 锁的强度是指它对其他锁的排斥程度。一个事务在申请封锁时以强锁代替弱锁是安全的，反之则不然。

3. 具有意向锁的多粒度封锁方法。
    1. 申请封锁时应该按自上而下的次序进行
    2. 释放封锁时则应该按自下而上的次序进行
    例如，事务T要对关系R加S锁，首先要对整个数据库加IS锁，再检查数据库和R是否加了不相容的锁；而不需要检查关系R中元组是否加锁，由于若元组加锁，也会体现在上层关系和数据库上。

4. 优点：
	1. 提高了系统并发度
	2. 减少了加锁和解锁的开销 <br>
    在实际的DBMS产品中得到广泛应用。

#### 9. 其他并发控制
并发控制的方法除了封锁技术外，还有时间戳方法、乐观控制法和多版本并发控制。
1. 时间戳方法：给每一个事务盖上一个时标，即事务开始的时间。每个事务具有唯一的时间戳，并按照这个时间戳来解决事务的冲突操作。如果发生冲突操作，就回滚到具有较早时间戳的事务，以保证其他事务的正常执行，被回滚的事务被赋予新的时间戳被从头开始执行。
2. 乐观控制法认为事务执行时很少发生冲突，所以不对事务进行特殊的管制，而是让它自由执行，事务提交前再进行正确性检查。如果检查后发现该事务执行中出现过冲突并影响了可串行性，则拒绝提交并回滚该事务。又称为验证方法。
3. 多版本控制MVCC是指在数据库中通过维护数据对象的多个版本信息来实现高效并发的一种策略。


