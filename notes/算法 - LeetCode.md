### DP
#### L5: 最长回文子串
dp[i][j] = true, if s[i...j]为回文串; 否则为false <br>
递归：
dp[i][j] == (s[i] == s[j]) && dp[i+1][j-1]

初始:
dp[i][i] = true
dp[i][i+1] == (s[i] == s[i+1])

归纳：
dp[i][j] == (s[i] == s[j]) && (j - i < 3 || dp[i+1][j-1])

#### L10 正则匹配
1. dp[i][j]:分别表示s[0...i-1]与p[0...j-1]是否匹配；最终判断dp[m][n]

2. 递归：sc=s[i-1] pc=p[j-1] <br>
若sc==pc || pc == ".", 则dp[i][j] = dp[i-1][j-1] <br>
否则，若pc="*", pc2=p[j-2]  <br>
若sc==pc2 || pc2 == "."，则有三种匹配方式:匹配0/多个字符 <br>
dp[i][j] = dp[i][j-2] || dp[i-1][j]
否则，只匹配0个字符 dp[i][j] = dp[i][j-2]

#### L33 有效括号个数 **
1. dp解法
    1. dp[i]表示以s[i]为底的最长有效括号长度
    dp[0]= 0
    s[i]==),
    若s[i-1]==(，则dp[i]=(i>1?dp[i-2]:0)+2
    若s[i-1]==),则dp[i-1]表示s[i-1]为底的括号长度，因此i-d[i-1]-1表示该长度的起始点前一个位置；若s[i-dp[i-1]-1]=(,即正好与s[i]构成一个括号
    dp[i] = dp[i-1] + ((i - dp[i-1]) >= 2 ? dp[i - dp[i-1] - 2] : 0) + 2;

2. 栈模拟 <br>
    初始插入-1,表示起始位置
    当遇到(,将当前下标入栈
    当遇到),先弹出栈顶；若栈为空表明前一个有效序列已经扫描，将当前下标入栈；否则，计算i-s.peek()表示当前有效长度。peek为弹出栈顶后的元素。

#### L44 正则匹配2
1. 参照1，dp[i][j] denotes whether s[0....i-1] matches p[0.....j-1]
dp[i][0] = false
dp[0][j] = true, if s[0...j-1] = "****"

递归
if p[j-1] == *； 匹配0个或多个
dp[i][j] = dp[i][j-1] || dp[i-1][j]
否则，
dp[i][j] = dp[i-1][j-1] && (s.charAt(i-1)==p.charAt(j-1) || p.charAt(j-1)=='?');


#### L53 最长连续子数组
dp[i] = a[i], dp[i-1]  < 0
dp[i] = a[i] + dp[i-1], dp[i-1] >= 0

#### L62 矩阵移动路径数
dp[i][j]表示移动到(i,j)的路径数
dp[i][j] = dp[i-1][j] + dp[i][j-1]

初始
dp[i][0] = 1 
dp[0][j] = 1


#### L62 矩阵移动路径数2
1. 添加障碍，原理一致；障碍处dp[i][j] = 0

#### L64 矩阵路径最小和
dp[i][j]:从(0,0)到(i.j)最小路径和
dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + a[i][j]


#### L72 编辑距离
word1转换到word2的步骤数
dp[i][j]:将word1前i个字符[0...i-1]变成word2前j个字符[0...j-1]的最少步数.
初始
dp[0][j]=j dp[i][0]=i

若word1[i-1]==word2[j-1],则dp[i][j]=dp[i-1][j-1]
否则，有三种方式