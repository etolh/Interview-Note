[TOC]
## 书籍内容

## 题目详解
### 23 将一个二叉搜索树转换成有序双向链表

### 24 字符串排列

### 23 将一个二叉搜索树转换成有序双向链表

### 033 逆序对
一个数与自己异或为0,n^n=0

### 44 约瑟夫环
1. 首先n个人[0 1 2  ... n-1]删除第m个人，因此被删除的第m个人是m%n-1;
下一轮n-1个人，从k1=m%n开始，重新数到第m%n个人；假设坐标映射
    + n -> (n-1)
    + k1 -> 0
    + k1+1 -> 1
    + k1+2 -> 2
    + ...
    + (k1+n-2)%(n-1) -> n-2
从n个人映射到n-1人坐标 fn(x) = (x - k1 + n) % n;
x-k表示在与k的距离（k表示新开始), +n是循环数组4

在新映射的坐标里面，被删除的还是x=m%(n-1) - 1;
则x在原来n个人中下标为
fn-1(x) = (x+k1) % n = （x+ m%n)%n = (x+m)%n

举例:
n = 5 [0 1 2 3 4] m=3
n阶 [0 1 * 3 4]
n-1阶 [2 3 0 1] 删除后 [* 3 0 1]
+ n-1 -> n
+ 0 -> 3
+ 1 -> 4
+ 2 -> 0
+ 3 -> 1
第n-1阶向第n阶升阶 x->fn(x)
fn(x) = (x+m)%n = (x+3)%5

n-2阶 [0 1 2] 删除【0 1 *】
+ n-2 -> n-1
+ 0 -> 3
+ 1 -> 0
+ 2 -> 1
第n-2阶向第n-1阶升阶 
fn-1(x) = (x+m)%(n-1) = (x+3)%4

因此，从第i-1阶上升到第i阶
x -> (x+m)%i

当只剩一个即第一阶，胜出f0=0
f1=(f0+m)%1
f2=(f1+m)%2
...
fn=(fn-1+m)%n

#### 扩展
求约瑟夫环第i次抛弃的下标
##### 类推扩展
1. n阶环中抛弃第2个数，相当于：
    1. n阶环先抛弃第1个、 n阶环再抛弃第2个
    2. n阶环抛弃第1个 、 n-1阶环抛弃第1个

2. n阶环中抛弃第3个数，相当于：
    1. n阶环抛弃第1个、 n阶环抛弃第2个、n阶环抛弃第3个
    2. n阶环抛弃第1个 、 剩余n-1阶环抛弃第1个、剩余n-1阶环抛弃第2个
    3. n阶环抛弃第1个 、 剩余n-1阶环抛弃第1个、剩余n-2阶环抛弃第1个

......

3. n阶环中抛弃第c个数，相当于：
    1. n阶环抛弃第1个、 n阶环抛弃第2个… n阶环抛弃第c个
    2. n阶环抛弃第1个 、 剩余n-1阶环抛弃第1个…剩余n-1阶环抛弃第c-1个
    3. n阶环抛弃第1个 、 剩余n-1阶环抛弃第1个…剩余n-c+1阶环抛弃第1个

因此，n阶环抛弃的第i个数，即是n-1阶环中抛弃的第i-1个数，也是第n-c+1环抛弃的第一个数，再不断映射到n阶环坐标。
n-c+1环第一个抛弃的坐标k=(m-1)%(n-c+1)

##### 实现
1. 函数
```java
    // n阶环第i次抛出的数：n-1阶环中第i-1次抛出的数，经过映射
    private int dropRe(int n, int m, int i) {

        if (i==1)
            return (m-1)%n; // 第一次抛出
        else {  // n-1阶环抛弃第i-1个
            int r = dropRe(n-1, m, i-1);
            return (r+m)%n;
        }
    }

    // 非递归：n阶环第i次抛出的数: n-i+1阶环第一次抛出，再向上迭代
    private int drop(int n, int m, int i) {

        int begin = (n-i+1);
        int rn1 = (m-1) % begin;  // n-i+1阶环第一次抛出位置

        for (int j = begin+1; j <= n; j++)
            rn1 = (rn1 + m) % j;    // 向上迭代

        return rn1;
    }
```

2. 求n阶环中最后剩余的数字，即n阶环中第n次抛出的数，n-1阶环中第n-1次抛出的数….，求剩余数，也可以求n阶环中后n-c+1次抛出的数，即c次抛出剩余的数。

参考资料：https://www.cnblogs.com/cmmdc/p/7216726.html


### 61 数据流的中位数
     * 使用大根堆和小根堆两个数组存储所有数据，
     * 且当整体为偶数时，大根堆和小根堆数据一样，为奇数时，大根堆=小根堆+1
     * 大根堆的最大数据 < 小根堆的最小数据；因此中位数=堆顶元素/2(偶数) 中位数=大根堆堆顶
     *
     * 即插入过程中，使得
     * 1. 大根堆的最大数据 < 小根堆的最小数据
     * 2. 大根堆数据个数 = [小根堆, 小根堆+1]
     *
     * 传入的数据为：[5,2,3,4,1,6,7,0,8],那么按照要求，输出是"5.00 3.50 3.00 3.50 3.00 3.50 4.00 3.50 4.00 "
     *
     * 实现方式：
     * 小根堆存大数，大根堆存小数
     * 插入
     * 1. 当插入奇数位数时，先插入到小根堆，再将小根堆中最小数插入到大根堆
     * 2. 当插入偶数位数时，先插入到大根堆，再将大根堆中最大数插入到小根堆
     *
     * 1/2能够保证大数永远在小根堆，小数永远在大根堆
     * 同时由于分别插入在大根堆和小根堆，所以个数差在1之间。
     *
     * 获取:
     * 1. 取中位数时，若个数为偶数，取大小根堆堆顶元素平均数
     * 若个数为奇数，取大根堆堆顶

     https://sunweiguo.github.io/2019/03/18/%E5%89%91%E6%8C%87offer/%E3%80%90%E9%9D%A2%E8%AF%95%E9%A2%9863-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%E3%80%91/

### 62 滑动窗口最大值

### 63 
## 方法总结
1. 针对某个复杂或难以理解的问题，使用简单案例得到答案；
如二分查找中若无target，返回target插入位置，使用[1 2 3]插入2.5可以最终插入位置是start。

```java
private int binarySearch(int[] array, double k){
    int s = 0, e = array.length - 1;
    while (true){
        if (s > e){
            break;
        }
        int mid = (s +  e) / 2;
        if (array[mid] < k){
            s = mid + 1;
        }else if (array[mid] > k){
            e = mid - 1;
        }
    }
    return s;
}
```